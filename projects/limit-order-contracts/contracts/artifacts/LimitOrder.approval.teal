#pragma version 10
intcblock 1 0 576 4 577 35300
bytecblock 0x6f72646572496e646578 0x 0x00

// This TEAL was generated by TEALScript v0.106.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	intc 0 // 1
	return

// createApplication(): void
createApplication:
	proto 0 0

	// contracts\LimitOrder.algo.ts:22
	// this.orderIndex.value = 0
	bytec 0 //  "orderIndex"
	intc 1 // 0
	app_global_put
	retsub

// createOrder(txn,pay,uint64,uint64)uint64
*abi_route_createOrder:
	// The ABI return prefix
	pushbytes 0x151f7c75

	// takingAmount: uint64
	txna ApplicationArgs 2
	btoi

	// takingAsset: uint64
	txna ApplicationArgs 1
	btoi

	// mbrTxn: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 2 (mbrTxn) for createOrder must be a pay transaction
	assert

	// assetSendTxn: txn
	txn GroupIndex
	pushint 2
	-

	// execute createOrder(txn,pay,uint64,uint64)uint64
	callsub createOrder
	itob
	concat
	log
	intc 0 // 1
	return

// createOrder(assetSendTxn: Txn, mbrTxn: PayTxn, takingAsset: uint64, takingAmount: uint64): uint64
createOrder:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts\LimitOrder.algo.ts:26
	// assert(this.txn.sender.isOptedInToAsset(takingAsset), 'Taking asset is not opted in')
	txn Sender
	frame_dig -3 // takingAsset: uint64
	asset_holding_get AssetBalance
	swap
	pop

	// Taking asset is not opted in
	assert

	// contracts\LimitOrder.algo.ts:27
	// assert(assetSendTxn.sender === this.txn.sender, 'Invalid sender')
	frame_dig -1 // assetSendTxn: Txn
	gtxns Sender
	txn Sender
	==

	// Invalid sender
	assert

	// contracts\LimitOrder.algo.ts:28
	// order = this.buildOrder(assetSendTxn, takingAsset, takingAmount)
	frame_dig -4 // takingAmount: uint64
	frame_dig -3 // takingAsset: uint64
	frame_dig -1 // assetSendTxn: Txn
	callsub buildOrder
	frame_bury 0 // order: (uint64,address,uint64,uint64,uint64,uint64,bool,bool)

	// contracts\LimitOrder.algo.ts:29
	// verifyPayTxn(mbrTxn, { amount: { greaterThanEqualTo: BOX_MBR } })
	// verify amount
	frame_dig -2 // mbrTxn: PayTxn
	gtxns Amount
	intc 5 // 35300
	>=

	// transaction verification failed: {"txn":"mbrTxn","field":"amount","condition":"greaterThanEqualTo","expected":">=BOX_MBR"}
	assert

	// contracts\LimitOrder.algo.ts:30
	// this.orders(this.orderIndex.value).value = order
	bytec 0 //  "orderIndex"
	app_global_get
	itob
	frame_dig 0 // order: (uint64,address,uint64,uint64,uint64,uint64,bool,bool)
	box_put

	// contracts\LimitOrder.algo.ts:31
	// this.orderIndex.value += 1
	bytec 0 //  "orderIndex"
	app_global_get
	intc 0 // 1
	+
	bytec 0 //  "orderIndex"
	swap
	app_global_put

	// contracts\LimitOrder.algo.ts:32
	// return order.id;
	frame_dig 0 // order: (uint64,address,uint64,uint64,uint64,uint64,bool,bool)
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi

	// set the subroutine return value
	frame_bury 0
	retsub

// buildOrder(assetSendTxn: Txn, takingAsset: uint64, takingAmount: uint64): Order
buildOrder:
	proto 3 1

	// contracts\LimitOrder.algo.ts:36
	// assert(
	//       assetSendTxn.typeEnum === TransactionType.AssetTransfer || assetSendTxn.typeEnum === TransactionType.Payment,
	//       'Invalid transaction type'
	//     )
	frame_dig -1 // assetSendTxn: Txn
	gtxns TypeEnum
	intc 3 //  axfer
	==
	dup
	bnz *skip_or0
	frame_dig -1 // assetSendTxn: Txn
	gtxns TypeEnum
	intc 0 //  pay
	==
	||

*skip_or0:
	// Invalid transaction type
	assert

	// *if0_condition
	// contracts\LimitOrder.algo.ts:40
	// assetSendTxn.typeEnum === TransactionType.Payment
	frame_dig -1 // assetSendTxn: Txn
	gtxns TypeEnum
	intc 0 //  pay
	==
	bz *if0_end

	// *if0_consequent
	// contracts\LimitOrder.algo.ts:41
	// assert(assetSendTxn.receiver === this.app.address, 'Invalid receiver')
	frame_dig -1 // assetSendTxn: Txn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// Invalid receiver
	assert

	// contracts\LimitOrder.algo.ts:42
	// return {
	//         id: this.orderIndex.value,
	//         owner: this.txn.sender,
	//         givingAsset: 0,
	//         takingAsset: takingAsset,
	//         givingAmount: assetSendTxn.amount,
	//         takingAmount: takingAmount,
	//         completed: false,
	//         ownerClaimed: false,
	//       };
	bytec 0 //  "orderIndex"
	app_global_get
	itob
	txn Sender
	concat
	pushbytes 0x0000000000000000
	concat
	frame_dig -2 // takingAsset: uint64
	itob
	concat
	frame_dig -1 // assetSendTxn: Txn
	gtxns Amount
	itob
	concat
	frame_dig -3 // takingAmount: uint64
	itob
	concat
	bytec 2 // 0x00
	intc 1 // 0
	dup
	setbit
	intc 0 // 1
	intc 1 // 0
	setbit
	concat
	retsub

*if0_end:
	// contracts\LimitOrder.algo.ts:53
	// assert(assetSendTxn.assetReceiver === this.app.address, 'Invalid receiver')
	frame_dig -1 // assetSendTxn: Txn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// Invalid receiver
	assert

	// contracts\LimitOrder.algo.ts:54
	// return {
	//       id: this.orderIndex.value,
	//       owner: this.txn.sender,
	//       givingAsset: assetSendTxn.xferAsset.id,
	//       takingAsset: takingAsset,
	//       givingAmount: assetSendTxn.assetAmount,
	//       takingAmount: takingAmount,
	//       completed: false,
	//       ownerClaimed: false,
	//     };
	bytec 0 //  "orderIndex"
	app_global_get
	itob
	txn Sender
	concat
	frame_dig -1 // assetSendTxn: Txn
	gtxns XferAsset
	itob
	concat
	frame_dig -2 // takingAsset: uint64
	itob
	concat
	frame_dig -1 // assetSendTxn: Txn
	gtxns AssetAmount
	itob
	concat
	frame_dig -3 // takingAmount: uint64
	itob
	concat
	bytec 2 // 0x00
	intc 1 // 0
	dup
	setbit
	intc 0 // 1
	intc 1 // 0
	setbit
	concat
	retsub

// claimOrder(uint64,txn)void
*abi_route_claimOrder:
	// assetSendTxn: txn
	txn GroupIndex
	intc 0 // 1
	-

	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute claimOrder(uint64,txn)void
	callsub claimOrder
	intc 0 // 1
	return

// claimOrder(orderId: uint64, assetSendTxn: Txn): void
claimOrder:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// contracts\LimitOrder.algo.ts:67
	// assert(this.orders(orderId).exists, 'Order not found')
	frame_dig -1 // orderId: uint64
	itob
	box_len
	swap
	pop

	// Order not found
	assert

	// contracts\LimitOrder.algo.ts:68
	// order = this.orders(orderId).value
	frame_dig -1 // orderId: uint64
	itob
	frame_bury 0 // storage key//order

	// contracts\LimitOrder.algo.ts:69
	// assert(!order.completed, 'Order already completed')
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	intc 2 // 576
	getbit
	!

	// Order already completed
	assert

	// contracts\LimitOrder.algo.ts:70
	// assert(
	//       assetSendTxn.typeEnum === TransactionType.AssetTransfer || assetSendTxn.typeEnum === TransactionType.Payment,
	//       'Invalid transaction type'
	//     )
	frame_dig -2 // assetSendTxn: Txn
	gtxns TypeEnum
	intc 3 //  axfer
	==
	dup
	bnz *skip_or1
	frame_dig -2 // assetSendTxn: Txn
	gtxns TypeEnum
	intc 0 //  pay
	==
	||

*skip_or1:
	// Invalid transaction type
	assert

	// *if1_condition
	// contracts\LimitOrder.algo.ts:74
	// assetSendTxn.typeEnum === TransactionType.Payment
	frame_dig -2 // assetSendTxn: Txn
	gtxns TypeEnum
	intc 0 //  pay
	==
	bz *if1_else

	// *if1_consequent
	// contracts\LimitOrder.algo.ts:75
	// assert(order.takingAsset === 0, 'Invalid giving asset')
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 48 8
	btoi
	intc 1 // 0
	==

	// Invalid giving asset
	assert

	// contracts\LimitOrder.algo.ts:76
	// assert(order.takingAmount === assetSendTxn.amount, 'Invalid giving amount')
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 64 8
	btoi
	frame_dig -2 // assetSendTxn: Txn
	gtxns Amount
	==

	// Invalid giving amount
	assert

	// contracts\LimitOrder.algo.ts:77
	// assert(this.txn.sender === assetSendTxn.sender, 'Invalid sender')
	txn Sender
	frame_dig -2 // assetSendTxn: Txn
	gtxns Sender
	==

	// Invalid sender
	assert

	// contracts\LimitOrder.algo.ts:78
	// assert(this.app.address === assetSendTxn.receiver, 'Invalid receiver')
	global CurrentApplicationAddress
	frame_dig -2 // assetSendTxn: Txn
	gtxns Receiver
	==

	// Invalid receiver
	assert
	b *if1_end

*if1_else:
	// contracts\LimitOrder.algo.ts:80
	// assert(order.takingAsset === assetSendTxn.xferAsset.id, 'Invalid giving asset')
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 48 8
	btoi
	frame_dig -2 // assetSendTxn: Txn
	gtxns XferAsset
	==

	// Invalid giving asset
	assert

	// contracts\LimitOrder.algo.ts:81
	// assert(order.takingAmount === assetSendTxn.assetAmount, 'Invalid giving amount')
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 64 8
	btoi
	frame_dig -2 // assetSendTxn: Txn
	gtxns AssetAmount
	==

	// Invalid giving amount
	assert

	// contracts\LimitOrder.algo.ts:82
	// assert(this.txn.sender === assetSendTxn.assetSender, 'Invalid sender')
	txn Sender
	frame_dig -2 // assetSendTxn: Txn
	gtxns AssetSender
	==

	// Invalid sender
	assert

	// contracts\LimitOrder.algo.ts:83
	// assert(this.app.address === assetSendTxn.assetReceiver, 'Invalid receiver')
	global CurrentApplicationAddress
	frame_dig -2 // assetSendTxn: Txn
	gtxns AssetReceiver
	==

	// Invalid receiver
	assert

*if1_end:
	// contracts\LimitOrder.algo.ts:85
	// this.orders(orderId).value.completed = true
	frame_dig -1 // orderId: uint64
	itob
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	intc 2 // 576
	intc 0 // 1
	setbit
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_replace

	// contracts\LimitOrder.algo.ts:86
	// this.send(order.givingAsset, order.givingAmount, this.txn.sender)
	txn Sender
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 56 8
	btoi
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 40 8
	btoi
	callsub send

	// *if2_condition
	// contracts\LimitOrder.algo.ts:87
	// order.takingAsset !== 0
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 48 8
	btoi
	intc 1 // 0
	!=
	bz *if2_else

	// *if2_consequent
	// contracts\LimitOrder.algo.ts:88
	// asset = AssetID.fromUint64(order.takingAsset)
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 48 8
	btoi
	frame_bury 1 // asset: uint64

	// *if3_condition
	// contracts\LimitOrder.algo.ts:89
	// order.owner.isOptedInToAsset(asset)
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 32
	frame_dig 1 // asset: uint64
	asset_holding_get AssetBalance
	swap
	pop
	bz *if3_end

	// *if3_consequent
	// contracts\LimitOrder.algo.ts:90
	// this.orders(orderId).value.ownerClaimed = true
	frame_dig -1 // orderId: uint64
	itob
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	intc 4 // 577
	intc 0 // 1
	setbit
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_replace

	// contracts\LimitOrder.algo.ts:91
	// this.send(order.takingAsset, order.takingAmount, order.owner)
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 32
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 64 8
	btoi
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 48 8
	btoi
	callsub send

*if3_end:
	b *if2_end

*if2_else:
	// contracts\LimitOrder.algo.ts:94
	// this.orders(orderId).value.ownerClaimed = true
	frame_dig -1 // orderId: uint64
	itob
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	intc 4 // 577
	intc 0 // 1
	setbit
	frame_dig -1 // orderId: uint64
	itob
	cover 2
	box_replace

	// contracts\LimitOrder.algo.ts:95
	// this.send(order.takingAsset, order.takingAmount, order.owner)
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 32
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 64 8
	btoi
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 48 8
	btoi
	callsub send

*if2_end:
	retsub

// claimOwnerAsset(uint64)void
*abi_route_claimOwnerAsset:
	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute claimOwnerAsset(uint64)void
	callsub claimOwnerAsset
	intc 0 // 1
	return

// claimOwnerAsset(orderId: uint64): void
claimOwnerAsset:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts\LimitOrder.algo.ts:100
	// assert(this.orders(orderId).exists, 'Order not found')
	frame_dig -1 // orderId: uint64
	itob
	box_len
	swap
	pop

	// Order not found
	assert

	// contracts\LimitOrder.algo.ts:101
	// order = this.orders(orderId).value
	frame_dig -1 // orderId: uint64
	itob
	frame_bury 0 // storage key//order

	// contracts\LimitOrder.algo.ts:102
	// assert(order.completed, 'Order not completed')
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	intc 2 // 576
	getbit

	// Order not completed
	assert

	// contracts\LimitOrder.algo.ts:103
	// assert(!order.ownerClaimed, 'Owner already claimed')
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	intc 4 // 577
	getbit
	!

	// Owner already claimed
	assert

	// contracts\LimitOrder.algo.ts:104
	// assert(this.txn.sender === order.owner, 'Invalid sender')
	txn Sender
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 32
	==

	// Invalid sender
	assert

	// contracts\LimitOrder.algo.ts:105
	// this.orders(orderId).value = {
	//       id: order.id,
	//       owner: order.owner,
	//       givingAsset: order.givingAsset,
	//       takingAsset: order.takingAsset,
	//       givingAmount: order.givingAmount,
	//       takingAmount: order.takingAmount,
	//       completed: order.completed,
	//       ownerClaimed: true,
	//     }
	frame_dig -1 // orderId: uint64
	itob
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	itob
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 32
	concat
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 40 8
	btoi
	itob
	concat
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 48 8
	btoi
	itob
	concat
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 56 8
	btoi
	itob
	concat
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 64 8
	btoi
	itob
	concat
	bytec 2 // 0x00
	intc 1 // 0
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	intc 2 // 576
	getbit
	setbit
	intc 0 // 1
	dup
	setbit
	concat
	box_put

	// contracts\LimitOrder.algo.ts:115
	// this.send(order.takingAsset, order.takingAmount, order.owner)
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 32
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 64 8
	btoi
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 48 8
	btoi
	callsub send
	retsub

// optInToAsset(uint64,pay)void
*abi_route_optInToAsset:
	// mbrTxn: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 0 (mbrTxn) for optInToAsset must be a pay transaction
	assert

	// assetId: uint64
	txna ApplicationArgs 1
	btoi

	// execute optInToAsset(uint64,pay)void
	callsub optInToAsset
	intc 0 // 1
	return

// optInToAsset(assetId: AssetID, mbrTxn: PayTxn): void
optInToAsset:
	proto 2 0

	// contracts\LimitOrder.algo.ts:119
	// assert(!this.app.address.isOptedInToAsset(assetId), 'Already opted in')
	global CurrentApplicationAddress
	frame_dig -1 // assetId: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!

	// Already opted in
	assert

	// contracts\LimitOrder.algo.ts:120
	// verifyPayTxn(mbrTxn, { amount: { greaterThanEqualTo: globals.assetOptInMinBalance } })
	// verify amount
	frame_dig -2 // mbrTxn: PayTxn
	gtxns Amount
	global AssetOptInMinBalance
	>=

	// transaction verification failed: {"txn":"mbrTxn","field":"amount","condition":"greaterThanEqualTo","expected":">=globals.assetOptInMinBalance"}
	assert

	// contracts\LimitOrder.algo.ts:121
	// sendAssetTransfer({ xferAsset: assetId, assetReceiver: this.app.address, assetAmount: 0 })
	itxn_begin
	intc 3 //  axfer
	itxn_field TypeEnum

	// contracts\LimitOrder.algo.ts:121
	// xferAsset: assetId
	frame_dig -1 // assetId: AssetID
	itxn_field XferAsset

	// contracts\LimitOrder.algo.ts:121
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts\LimitOrder.algo.ts:121
	// assetAmount: 0
	intc 1 // 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// cancelOrder(uint64)void
*abi_route_cancelOrder:
	// orderId: uint64
	txna ApplicationArgs 1
	btoi

	// execute cancelOrder(uint64)void
	callsub cancelOrder
	intc 0 // 1
	return

// cancelOrder(orderId: uint64): void
cancelOrder:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts\LimitOrder.algo.ts:125
	// assert(this.orders(orderId).exists, 'Order not found')
	frame_dig -1 // orderId: uint64
	itob
	box_len
	swap
	pop

	// Order not found
	assert

	// contracts\LimitOrder.algo.ts:126
	// order = this.orders(orderId).value
	frame_dig -1 // orderId: uint64
	itob
	frame_bury 0 // storage key//order

	// contracts\LimitOrder.algo.ts:127
	// assert(order.owner === this.txn.sender, 'Invalid sender')
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 32
	txn Sender
	==

	// Invalid sender
	assert

	// contracts\LimitOrder.algo.ts:128
	// assert(!order.completed, 'Order already completed')
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	intc 2 // 576
	getbit
	!

	// Order already completed
	assert

	// contracts\LimitOrder.algo.ts:129
	// this.orders(orderId).delete()
	frame_dig -1 // orderId: uint64
	itob
	box_del

	// contracts\LimitOrder.algo.ts:130
	// this.send(order.givingAsset, order.givingAmount, this.txn.sender)
	txn Sender
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 56 8
	btoi
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 40 8
	btoi
	callsub send

	// contracts\LimitOrder.algo.ts:131
	// sendPayment({ receiver: order.owner, amount: BOX_MBR })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts\LimitOrder.algo.ts:131
	// receiver: order.owner
	frame_dig 0 // storage key//order
	box_get

	// box value does not exist: this.orders(orderId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 32
	itxn_field Receiver

	// contracts\LimitOrder.algo.ts:131
	// amount: BOX_MBR
	intc 5 // 35300
	itxn_field Amount

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// send(asset: uint64, amount: uint64, receiver: Address): void
send:
	proto 3 0

	// *if4_condition
	// contracts\LimitOrder.algo.ts:135
	// asset === 0
	frame_dig -1 // asset: uint64
	intc 1 // 0
	==
	bz *if4_else

	// *if4_consequent
	// contracts\LimitOrder.algo.ts:136
	// sendPayment({ receiver: receiver, amount: amount })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts\LimitOrder.algo.ts:136
	// receiver: receiver
	frame_dig -3 // receiver: Address
	itxn_field Receiver

	// contracts\LimitOrder.algo.ts:136
	// amount: amount
	frame_dig -2 // amount: uint64
	itxn_field Amount

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if4_end

*if4_else:
	// contracts\LimitOrder.algo.ts:138
	// sendAssetTransfer({
	//         assetReceiver: receiver,
	//         assetAmount: amount,
	//         xferAsset: AssetID.fromUint64(asset),
	//       })
	itxn_begin
	intc 3 //  axfer
	itxn_field TypeEnum

	// contracts\LimitOrder.algo.ts:139
	// assetReceiver: receiver
	frame_dig -3 // receiver: Address
	itxn_field AssetReceiver

	// contracts\LimitOrder.algo.ts:140
	// assetAmount: amount
	frame_dig -2 // amount: uint64
	itxn_field AssetAmount

	// contracts\LimitOrder.algo.ts:141
	// xferAsset: AssetID.fromUint64(asset)
	frame_dig -1 // asset: uint64
	itxn_field XferAsset

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if4_end:
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x2a2431dd // method "createOrder(txn,pay,uint64,uint64)uint64"
	pushbytes 0x0a781e29 // method "claimOrder(uint64,txn)void"
	pushbytes 0x9cdd17a6 // method "claimOwnerAsset(uint64)void"
	pushbytes 0x5c012989 // method "optInToAsset(uint64,pay)void"
	pushbytes 0x34dfc3ed // method "cancelOrder(uint64)void"
	txna ApplicationArgs 0
	match *abi_route_createOrder *abi_route_claimOrder *abi_route_claimOwnerAsset *abi_route_optInToAsset *abi_route_cancelOrder

	// this contract does not implement the given ABI method for call NoOp
	err